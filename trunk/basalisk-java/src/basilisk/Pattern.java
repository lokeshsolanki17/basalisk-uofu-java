package basilisk;

/**
 * Used to represent an extraction pattern as generated by autoslog. An extraction pattern essentially contains the context information
 * for a the noun phrases identified by autoslog. A Pattern, then is just a sequence of characters generated by autoslog. A pattern
 * also contains a variable to store the score it receives from Basilisk.<br/><br/>
 * 
 * An example pattern might look like: <br/>
 * InfVp_Prep_(NP)__ADVANCE_IN_26 <br/><br/>
 * 
 * Two patterns are considered equal if they contain the same sequence of characters, case insensitive.<br/><br/>
 * 
 * One pattern is considered less than another Pattern if it has a lower score than that Pattern. This means that Pattern's can be
 * sorted by descending score by collections that naturally sort their elements (TreeSet). However, because comparisons between two 
 * Pattern's are only based on their score, a TreeSet will return unreliable results when it is asked whether it contains or particular
 * Pattern or not. For this reason, use non-sorted collections whenever there is a need to ask the collection about which Pattern's it
 * contains. Use sorted collections to easily select the highest scoring Pattern's for a given set. 
 * 
 * @author John Tabet
 */
public class Pattern implements Comparable<Pattern> {

	private static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Pattern p1 = new Pattern("InfVp_Prep_<NP>__ADVANCE_IN_26");
		Pattern p2 = new Pattern("Infvp_Prep_<NP>__ADVANCE_IN_26");
		System.out.println(p1.equals(p2));

	}
	
	
	public final String _caseFrame;
	private double _score;
	
	/**
	 * Initializes a new pattern with the given input String. Also initializes the score to a default value of -1.0
	 * 
	 * @param s - Input string that reperesents the Pattern to be initialized.
	 */
	public Pattern(String s){
		_caseFrame = s;
		_score = -1.0; 	//default score
	}

	@Override 
	/**
	 * Two Pattern's are considered equal if they represent the same sequence of characters, case insensitive. 
	 */
	public boolean equals(Object o){
		if(this == o)
			return true;
		if((o instanceof Pattern) && ((Pattern) o)._caseFrame.equalsIgnoreCase(_caseFrame))
			return true;
		return false;
	}
	
	/**
	 * Resets the score of the Pattern to -1.0
	 */
	public void clearScore(){
		_score = -1.0;
	}
	
	/**
	 * Sets the score of the Pattern to the given input value.
	 * @param s - Score to which the Pattern is to have its score set.
	 */
	public void setScore(double s){
		_score = s;
	}
	
	/**
	 * Calls the hashCode method on the underlying String that the Pattern represents. The call is case insensitive. 
	 */
	public int hashCode(){
		return _caseFrame.toLowerCase().hashCode();
	}
	
	/**
	 * Returns the String that the Pattern represents.
	 */
	public String toString(){
		return _caseFrame;
	}
	
	/**
	 * Returns the String that the Pattern represents, along with its score, separated by a comma.
	 */
	public String toStringWithScore(){
		return _caseFrame  + ", Score: " + _score;
	}
	
	/**
	 * Sorts Pattern in descending order, from highest score to lowest score. See the main class notes about how this affects
	 * collections that Pattern's are stored in.
	 */
	@Override
	public int compareTo(Pattern p2) {
		if(_score == p2._score){
			return _caseFrame.toLowerCase().compareTo(p2._caseFrame.toLowerCase());
		}
		if(_score < p2._score)
			return -1;
		else if(_score > p2._score)
			return 1;
		else return 0;
	}
	
	public double getScore(){
		return _score;
	}


}
